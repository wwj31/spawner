package main

import (
	"flag"
	"fmt"
	"go/ast"
	"golang.org/x/tools/go/packages"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
)

var _pool = flag.Bool("pool", false, "support sync.pool")

func main() {
	flag.Parse()
	genFile()
	exec.Command("go", "fmt").Output()
}
func genFile() {
	var (
		packName string
		structs  []string
	)

	pack := parsePackage(nil, nil)
	for _, astFile := range pack.Syntax {
		for name, obj := range astFile.Scope.Objects {
			if spec, ok := obj.Decl.(*ast.TypeSpec); ok {
				if _, ok2 := spec.Type.(*ast.StructType); ok2 {
					packName = astFile.Name.Name
					structs = append(structs, name)
				}
			}
		}
	}
	sort.Slice(structs, func(i, j int) bool { return structs[i] > structs[j] })
	outputFactoryFile(
		filepath.Join("./", strings.ToLower(fmt.Sprintf("spawner_factory.go"))),
		packName,
		structs,
		*_pool,
	)

	if *_pool {
		outputPoolFile(
			filepath.Join("./", strings.ToLower(fmt.Sprintf("spawner_pool.go"))),
			packName,
			structs,
		)
	}

}

// parsePackage analyzes the single package constructed from the patterns and tags.
func parsePackage(patterns []string, tags []string) *packages.Package {
	cfg := &packages.Config{
		Mode:       packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	return pkgs[0]
}

func outputFactoryFile(output, packageName string, structs []string, newPool bool) {
	_ = os.Remove(output)
	file, err := os.Create(output)
	if err != nil {
		log.Fatalf("error: %v outputFactoryFile", err)
	}
	var (
		mapContext, newFunc, poolPut string
	)

	for _, val := range structs {
		// provide factory func
		mapContext += strings.NewReplacer([]string{
			"{name}", val,
			"{package}", packageName,
		}...).Replace(tplMapField)
	}

	if newPool {
		newFunc = tplSpawnerPool
		poolPut = tplPoolPut
	} else {
		newFunc = tplSpawner
		poolPut = tplWithoutPoolPut
	}
	context := strings.NewReplacer([]string{
		"{comment}", fmt.Sprintf("// Code generated by \"spawner %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " ")),
		"{package}", packageName,
		"{spawnerFunc}", newFunc,
		"{mapContext}", mapContext,
		"{poolPut}", poolPut,
	}...).Replace(tplFactoryOutline)

	_, _ = file.WriteString(context)
	_ = file.Close()
}

func outputPoolFile(output, packagename string, structs []string) {
	_ = os.Remove(output)
	file, err := os.Create(output)
	if err != nil {
		log.Fatalf("error: %v outputFactoryFile", err)
	}
	var (
		mapContext, newFunc string
	)

	for _, val := range structs {
		// provide pool new
		mapContext += strings.NewReplacer([]string{
			"{name}", val,
			"{package}", packagename,
		}...).Replace(tplMapPoolField)
	}

	context := strings.NewReplacer([]string{
		"{comment}", fmt.Sprintf("// Code generated by \"spawner %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " ")),
		"{package}", packagename,
		"{spawnerFunc}", newFunc,
		"{poolObject}", mapContext,
	}...).Replace(tplPoolOutline)

	_, _ = file.WriteString(context)
	_ = file.Close()
}

func strFirstToUpper(str string) string {
	if len(str) < 1 {
		return ""
	}
	strArry := []rune(str)
	if strArry[0] >= 97 && strArry[0] <= 122 {
		strArry[0] -= 32
	}
	return string(strArry)
}
